# Lattice Part 0



# 1.Lattice(格) 基础

> 基于数学与计算机，现代密码学诞生。

<!--more-->

## 1.1 Lattice

![image-20230401150649475](https://s2.loli.net/2023/04/26/LiFfTuMdwpvIsC1.png)

 

> 系统性的定义一下Lattice的话，那么我们可以说Lattice是R^n这个空间中的一个离散的、具有加法运算的子群（A discrete additive subgroup）。

结合可视化工具，这里给出辅助理解的图像：

![img](https://s2.loli.net/2023/04/26/dBiR15bsmONyjD3.jpg)

结合向量空间的概念，不难理解**格（Lattice)**与**基（bases)**的概念

![img](https://s2.loli.net/2023/04/26/RlDxybHqA1ZQhYn.jpg)



## 1.2 Lattice 的基本属性

### 1.2.1 Lattice 的密度

![image-20230401152921504](https://s2.loli.net/2023/04/26/thOBPMVRNm89Gkr.png)

即可理解为对应维度的向量空间内球体内所含有的格点数和球体体积之比（或超球体）

### 1.2.2 最短距离  λ

![image-20230401154409136](https://s2.loli.net/2023/04/26/InlxdERN5rDHihp.png)

将λ视为一个函数，λ1被定义为两格点间最小距离，推广至λn 

诸多λ遵循偏序关系:
$$
\lambda_1\leqslant\lambda_2\leqslant……\lambda_n-1\leqslant\lambda_n
$$
那么请注意到：**取等条件**：

> 选定笛卡尔坐标下的格

此时
$$
\lambda_1 =\lambda_2= …… =\lambda_n =1
$$

### 1.2.3 距离函数     μ（t,L）

注意到格是一个子群。

任取向量空间内一点，那么我们讨论距离这一点最近的一个格点，给出一些定义：

- 距离函数(Distance Function): **μ（t,L）**，认为**μ**的本质为数量
- 点 **t**

$$
\mu (t, L)= \min_{x∈L} \left \| t-x \right \|
$$



### 1.2.4 覆盖半径 μ（L)

类似地，我们认为**t**为动点，此时寻找**μ**的最大值。给出定义：

- 覆盖半径（Covering Radius): **μ（L)**
  $$
  \mu (L)= \max_{x∈span(L)} μ(t,L)
  $$

- 

对**覆盖**的理解：

以格点为圆心，不断扩大半径，可以容易地找到当各个圆刚好覆盖整个向量空间地时候，此时半径恰好为μ（L）。

<img src="https://s2.loli.net/2023/04/26/fjc1en5gWAmZlwx.jpg" alt="img"  />

这和Lattice 的Smoothing 高度相关。

## 1.3 Minkowski凸集定理

![image-20230401162641045](https://s2.loli.net/2023/04/26/nzgYQUsVNWaJ1vd.png)

**Fundamental Region**:

![image-20230401163135664](https://s2.loli.net/2023/04/26/6eDqdnPEcjHtNr5.png)

为了辅助理解：

> 数学上，给出一个拓扑空间和在其上作用的群，一个点在群作用下的像是这个作用的一个轨道。一个基本域是这个空间的一个子集，包含了每个轨道中恰好一点。基本域具体地用几何表现出抽象的轨道代表集。 构造基本域的方法有很多。一般会要求基本域是连通的，又对其边界加上一些限制，例如是光滑或是多面的。——wikipedia



凸集：暂可以理解为是一个多维空间的一部分（一个多维物体）(详细可见References)

![image-20230401162116756](https://s2.loli.net/2023/04/26/WXGwxMg4tskF1rl.png)

叠加了线性变换：

![image-20230401162537277](https://s2.loli.net/2023/04/26/VdrCAiguZSYnXbv.png)

![image-20230401172346626](https://s2.loli.net/2023/04/26/8quYfQ7gC6n5Nkl.png)

**重要应用：  给出了一个Lattice中，最短向量的一个上限值**

### 最短向量

> 对于一个Lattice，最短向量是指该Lattice中长度最小的非零向量，而（距离原点）距离最远的最短向量则是指该Lattice中长度最小的非零向量与原点的距离最远的那个向量。这个向量通常被称为Lattice的第一个**近邻向量**或**最优向量**。
>
> 计算Lattice的最短向量和最远的最短向量是一个重要的问题，因为它们在很多应用中都有着重要的作用。其中，计算最短向量是一个NP难问题，而计算最远的最短向量则是一个NP难问题的变体。目前，已经有很多算法被提出来用于解决这些问题，但是在实际应用中，它们的效率和精度都有一定的限制。

这里给出二维的表述：

> 坐标平面上任何包含原点的、面积大于4的、凸的、关于原点对称的闭区域一定含有异于原点的整点。

## 1.4Minkowski第二定理

Steven的理解：

![image-20230401172613154](https://s2.loli.net/2023/04/26/38Z1DX75WEKQatg.png)

结合向量空间，可以认为明可夫斯基第二定理给出了对于所有最短向量的的取值上限。

当然我们对det（L）做一些详细解释，以便结合曾经的明可夫斯基不等式来理解这一定理：

**行列式的几何意义**
$$
X^T = (a,c),X'^T = (b,d)\\
det(X^T,X'^T)  = S
$$
![img](https://s2.loli.net/2023/04/26/fEhLdZ3z8nBI5Q4.jpg)

二维情况下，行列式可以理解为对应平行四边形的面积。（暂不考虑复平面）注意我们这里将这一面积视为**有向**面积。（考虑到行列式的符号）

**行列式的部分性质**

- 行列式为零当且仅当两个向量共线（[线性相关](https://zh.wikipedia.org/wiki/线性相关)），这时平行四边形退化成一条直线[[9\]](https://zh.wikipedia.org/wiki/行列式#cite_note-autogenerated4-10)

- 行列式是一个[双线性映射](https://zh.wikipedia.org/wiki/双线性映射)。
  $$
  det(λX+μY,X') =λdet(X,X')+ μ(Y,X') \\
  det(X,λX'+μY') =λdet(X,X')+ μ(X,Y')
  $$

在基本了解行列式之后，不难在向量空间中理解第二定理所给出的不等式。

介绍一下代数层面的理解过程：

**明可夫斯基不等式**给出了LP空间上的三角不等式的表达，那么第二定理则可以在LP空间以介值的方式进行理解。

> 明可夫斯基,相信各大赛区的“羟基选手”都很熟悉（bushi），以它来引入某一空间，那么同样的，在此空间内理解第二定理。

# 2.Problem in Lattice （BasisOfCrypto)

> 在本章节仅仅罗列了一些难解问题

[维基百科中的本章内容](https://en.wikipedia.org/wiki/Lattice_problem)

## 2.1 SVP（Shortest Vector Problem）

SVP定义：

> 给定一个基为的Lattice ，找到一个这个基构成的格点，使得这个点距离0坐标点的距离最近。


$$
BX :X∈ \mathbb{Z^k}\\
\left \| Bx  \right \| \le \lambda_1
$$

可视化：

![img](https://s2.loli.net/2023/04/26/sW8PREa4jkGTYp5.webp)

如果所得到基底不合适，那么计算最短向量就不是一件容易的事情了。

**断言：严格的计算最短向量是困难的。** 这里并不给出其NP-Hard属性的证明。

**Simplify:**
$$
SVP_γ
$$

$$
BX :X∈ \mathbb{Z^k}\\
\left \| Bx  \right \| \le γ\lambda_1
$$

这时候的解，则不唯一了。

## 2.2CVP 

（Closest Vector Problem）CVP定义：

> 给定连续空间中任意的一个点**t**，找到距离这个点最近的格点**Bx**。

此时的t处于全集空间内，而寻找距离对应的距离最近的格点，这样一个问题。

![img](https://s2.loli.net/2023/04/26/4ypSNQHnVuqxmOe.webp)

约束距离：μ ,Lattice 的覆盖半径。
$$
Bx：x ∈\mathbb{Z^k}\\
||BX -t|| \le \mu
$$
覆盖半径μ给出了所有可能的t中距离格点的最长距离。

对CVP问题做同样的**Simplify：**
$$
Bx：x ∈\mathbb{Z^k}\\
||BX -t|| \le γ\mu
$$
同样的不唯一。



### 2.2.1 Bounded Distance Decording

(Bounded Distance Decording)

![image-20230403210654832](https://s2.loli.net/2023/04/26/NHmXAhx1rkGn2dL.png)

### 2.2.2  Absolute Distancea Decording

(Absolute Distancea Decording)

![image-20230403210723857](https://s2.loli.net/2023/04/26/EljLk1HbQZz2rJX.png)

## 2.3SIVP（Shortest Independent Vector Problem)

![image-20230403211142101](https://s2.loli.net/2023/04/26/JK69F8uD2X4BEC1.png)

![image-20230403211208157](https://s2.loli.net/2023/04/26/BwSutPpfNUnAoqC.png)

## 2.4问题与联系

NP-HARD

**Association:**

![img](https://s2.loli.net/2023/04/26/PRG6mv3iQkcxbKt.jpg)



对于这里没有提到的GapSVP和GapSIVP问题，可以在wikipedia中找到详细介绍。



### 2.4.1漏故而知新

理解了五大问题的基本思想和概念，那么我们把视野放在各个关系的联系上。

**从ADD问题到SIVP问题**：

几何上不难直观理解，找出SIVP的解，再以所得向量为基向量，不难得到ADD问题得解。

：

![image-20230405193151836](https://s2.loli.net/2023/04/26/wJrRNdyjkgx9YPo.png)



### 2.4.2基于格的信息传递

![image-20230405201119444](https://s2.loli.net/2023/04/26/aCUiuf6zvqY23Sc.png)

# 3.Lattice的几何构造

在2.4中我们提到了取整。

在笛卡尔坐标系下，取整数格，CVP问题变得简单。通过上下取证，我们可以迅速解决问题。

![image-20230405193738583](https://s2.loli.net/2023/04/26/lOqLNPmJXzvkn1Y.png)

通过把一组基进行变换，找到一组非常接近垂直的基向量的过程，称为 **Lattice Basis Reduction**

## 3.1 Gram-Schmidt 正交化

寻找一组正交向量作为基底，在Lattice中也有重大应用。

而应用的原理则为Det(L)的大小不随线性变换而改变。

### 3.1.1基本形式

![img](https://s2.loli.net/2023/04/26/8fYzGQxK3EbZSXJ.gif)

代数上：

![image-20230405200342709](https://s2.loli.net/2023/04/26/91GUrhDvIgYAqn4.png)



### 3.1.2代码

给出基于numpy库和sympy的代码：

**Numpy**:

```python
def my_gramSchmidt_np(vectors):        #Eg:vecetors = np.array([[1,2],[3,4]]) 
     def proj(x, u):
         u = unit_vec(u)
         return np.dot(x, u) * u
        
     def unit_vec(x):
         return x / np.linalg.norm(x)
     vectors = np.atleast_2d(vectors)
    
     if len(vectors) == 0:
         return []
     if len(vectors) == 1:
         return unit_vec(vectors)
    
     u = vectors[-1]
     basis = my_gramSchmidt_np(vectors[0:-1])
     w = np.atleast_2d(u - np.sum(proj(u, v) for v in basis))
     basis = np.append(basis, unit_vec(w), axis=0)
    
     return basis
```

**Sympy**:

```python
def my_gramSchmidt_sp(*vectors):
     normalize = True
 
     def project(a, b):
         return b * (a.dot(b, hermitian=True) / b.dot(b, hermitian=True))
 
     def perp_to_subspace(vec, basis):
 
         components = [project(vec, b) for b in basis]
 
         if len(basis) == 0:
             return vec
 
         return vec - reduce(lambda a, b: a + b, components)
 
     ret = []
     vectors = list(vectors)
 
     while len(vectors) > 0 and vectors[0].is_zero_matrix:
         del vectors[0]
 
     for vec in vectors:
         perp = perp_to_subspace(vec, ret)
 
         if not perp.is_zero_matrix:
             ret.append(Matrix(perp))
 
     if normalize:
         ret = [vec / vec.norm() for vec in ret]
 
     return ret
 
 def gram_schmidt_sp(V):
     # YOUR CODE HERE
     if type(V) is not sympy.MutableDenseMatrix:
         raise ValueError
     if len(V.tolist()) != len(V.tolist()[0]):
         raise ValueError
     V = np.array(V)
     V = np.transpose(V)
     V = Matrix(V)
     vlist = V.tolist()
     tmp_list = []
     for i in vlist:
         tmp_list.append(Matrix(i))
     result = my_gramSchmidt_sp(*tmp_list)
     if len(result) == len(tmp_list):
         ma_list = []
         for i in result:
             tmp_list = []
             for j in i:
                 tmp_list.append(j)
             tmp = tmp_list
             ma_list.append(tmp)
 
         result = Matrix(ma_list)
         return result
     else:
         ma_list = []
         for i in result:
             tmp_list = []
             for j in i:
                 tmp_list.append(j)
             tmp = tmp_list
             ma_list.append(tmp)
         result = Matrix(ma_list)
         result = Matrix(result).H
         result = result.row_join(Matrix([[0], [0]]))
         return result
```

**Sagemath**:

```python
# 定义向量组
v1 = vector([1, 0, 1])
v2 = vector([1, 1, 1])
v3 = vector([0, 1, 1])
vec_list = [v1, v2, v3]

# 使用 Gram-Schmidt 函数进行正交化
orth_list = GramSchmidt(vec_list)

# 输出正交向量组
for v in orth_list:
    print(v)
#在上面的代码中，我们首先定义了一个向量组，然后使用GramSchmidt函数将其转换为正交向量组。最后，我们遍历正交向量组并将其打印出来。

#需要注意的是，Gram-Schmidt函数只能在有限维向量空间上工作。如果您需要处理无限维向量空间，则需要使用其他方法。
```



## 3.2 Lattice Rounding （取整问题）

原基向量再正交化后得到新的基向量，但是同时也产生了新的不同于原来的格。

![img](https://s2.loli.net/2023/04/26/lbDHgkYICLuX1SG.webp)



![image-20230405200844938](https://s2.loli.net/2023/04/26/tjdfFzc9Qa3Lqvp.png)

![img](https://s2.loli.net/2023/04/26/73DhB4vPskLMTe2.webp)



平移：**t**，约束条件：

![image-20230405202659915](https://s2.loli.net/2023/04/26/3xz5aMAwvNISbC1.png)

![img](https://s2.loli.net/2023/04/26/FpIHxKPLcCQNMOY.webp)



在基于Lattice的信息传输中，使用了取整，蕴含了一个不等式：

![image-20230405202855669](https://s2.loli.net/2023/04/26/BDzn2WQLkiGlESf.png)



**取整求解的问题：**

![img](https://s2.loli.net/2023/04/26/lScBvrs4PbMG1eg.webp)



当我们做取整操作的时候，因为几何形状的原因，最后的得到的结果格点和CVP问题的真正解会略有误差。比如我们看上图，**t**的落点在内圈的这个小圆内，那么我们取整得到的一定会是CVP的正确解。

**正确解的条件：**

![image-20230405203021390](https://s2.loli.net/2023/04/26/23XNKlfJCHaPmWt.png)

上面的表述避免了使用各种不同范数的概念，可根据三维欧几里得空间辅助理解。

下图可辅助理解。


![Pasted image 20230401120211](https://s2.loli.net/2023/04/26/kf9hFYCHVRZPIpd.png)
































# References

- [稀有气体](https://www.zhihu.com/column/c_1190932930565013504)：斯坦福的经验交流
- [CTFwiki](https://ctf-wiki.org/crypto/asymmetric/lattice/overview/)
- [Wikipedia](https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%88%97%E5%BC%8F)
- [【非线性优化理论】凸集](https://zhuanlan.zhihu.com/p/553134004#:~:text=%E5%87%B8%E9%9B%86%E7%9A%84%E5%AE%9A%E4%B9%89%20%E5%AE%9A%E4%B9%891%EF%BC%9A%20%E5%A6%82%E6%9E%9C%E9%9B%86%E5%90%88%20C%20subseteq%20mathbb%20%7BR%7D%5En%20%E4%B8%AD%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%A4%E7%82%B9,%7Bx%7D%2B%20%281-lambda%29mathbf%20%7By%7D%20in%20C%20%EF%BC%8C%E5%88%99%E7%A7%B0%E9%9B%86%E5%90%88%20C%20%E4%B8%BA%E5%87%B8%E9%9B%86)
- [Lattice Reduction Attacks on RSA](https://www.davidwong.fr/papers/david_wong_rsa_lll_boneh_durfee__2015.pdf)
- [A systematic approach to lattice models with solvable boundary states of arbitrary codimension](https://arxiv.org/pdf/1809.05293.pdf)
- [An Introduction to Lenstra-Lenstra-Lovasz Lattice Basis Reduction Algorithm](https://math.mit.edu/~apost/courses/18.204-2016/18.204_Xinyue_Deng_final_paper.pdf)



